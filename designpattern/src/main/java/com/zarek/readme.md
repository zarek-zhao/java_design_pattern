抛出一个问题？
模拟鸭子应用
鸭子一遍游泳划水，一遍呱呱叫
## 软件设计模式的产生背景
“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

1977年，美国著名建筑大师克里斯托夫·亚历山大在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

1979年，他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。

1987年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。

1990年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。

1995年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。

直到今天，狭义的设计模式是 GoF 23 种经典设计模式。

## 软件设计模式的目的
为了提高代码的可重用性、代码的可阅读性和代码的可靠性

## 软件设计模式的七大设计原则
* 开闭原则（Open Closed Principle，OCP）：对拓展开放，对修改关闭
* 单一职责原则（Single Responsibility Principle，SRP）：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
* 接口隔离原则（Interface Segregation Principle，ISP）：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
* 依赖倒置原则（Dependence Inversion Principle，DIP）：面向接口编程，不要面向实现编程；高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
* 里氏替换原则（Liskov Substitution Principle，LSP）：继承必须确保超类所拥有的性质在子类中仍然成立，也就是说子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
* 迪米特法则（Law of Demeter，LoD）：只与你的直接朋友通信 “朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数
* 合成复用原则（Composite Reuse Principle，CRP）：软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现

## GoF 23种 设计模式的划分

#### 根据作用范围来分
* 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。
* 对象模式 ：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。

举个例子：例如适配器模式

适配器模式（Adapter）包含以下主要角色。
1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器 
   - 类模式实现：适配器类 通过继承适配者，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者
   - 对象模式实现：适配器类 通过引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者

#### 根据目的分类
* 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”
* 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构
* 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责

##### 创建型模式
* 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展为有限多例模式
  * 应用场景：
    - 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
    - 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
    - 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
    - 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
    - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
  * 实现方式：
     - 饿汉式
       1. 静态变量
       2. 静态代码块
     - 懒汉式
       1. 同步代码块
       2. 双重检查 （推荐）  
       3. 静态内部类（推荐）
       4. 枚举类（强烈推荐 effective java）
  * jdk 源码举例：RunTime ：每个Java应用程序都有一个Runtime类的Runtime ，允许应用程序与运行应用程序的环境进行接口。当前运行时可以从getRuntime方法获得。
    
* 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品
  * 应用场景：DruidDataSourceFactory 
* 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例
  * 原型模式的优点：
    * Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
    * 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。
  * 原型模式的缺点：
    * 需要为每一个类都配置一个 clone 方法
    * clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
    * 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。
  * 模式
    * 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    * 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
  * 应用场景
    * 对象之间相同或相似，即只是个别的几个属性不同的时候。
    * 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
    * 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
    * 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
* 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象
  * 应用场景：
    * 相同的方法，不同的执行顺序，产生不同的结果。
    * 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
    * 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
    * 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。
  * 举例：Guava 的 ThreadFactoryBuilder()

## reference：
* C语言编程网-JAVA设计模式 http://c.biancheng.net/view/1317.html
* 菜鸟教程-设计模式 https://www.runoob.com/design-pattern/design-pattern-tutorial.html
* 双重检查锁定与延迟初始化 https://www.infoq.cn/article/double-checked-locking-with-delay-initialization/
* 模式PK：工厂模式VS建造者模式 https://www.cnblogs.com/ChinaHook/p/7471470.html

![img.png](img.png)